<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Sistema com PDF de Alta Qualidade - Sergipe</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- PDF.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f0f2f5;
    overflow: hidden;
  }

  header {
    background: linear-gradient(135deg, #0b3c5d 0%, #1a5276 100%);
    color: white;
    padding: 15px 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 100;
    position: relative;
  }

  header h1 {
    font-size: 24px;
    margin-bottom: 3px;
  }

  header p {
    font-size: 13px;
    opacity: 0.9;
  }

  #container {
    display: flex;
    height: calc(100vh - 85px);
  }

  #mapArea {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: #525659;
    cursor: grab;
  }

  #mapArea.dragging {
    cursor: grabbing;
  }

  #mapContainer {
    position: absolute;
    transform-origin: 0 0;
  }

  #pdfCanvas {
    display: block;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  }

  #markerCanvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
  }

  .zoom-controls {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 10;
  }

  .zoom-btn {
    width: 50px;
    height: 50px;
    background: white;
    border: 2px solid #0b3c5d;
    border-radius: 8px;
    font-size: 24px;
    font-weight: bold;
    color: #0b3c5d;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .zoom-btn:hover {
    background: #0b3c5d;
    color: white;
    transform: scale(1.1);
  }

  .zoom-btn:active {
    transform: scale(0.95);
  }

  .info-overlay {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: bold;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .loading-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 20px 30px;
    border-radius: 10px;
    font-size: 16px;
    z-index: 100;
  }

  #sidebar {
    width: 380px;
    background: white;
    box-shadow: -2px 0 10px rgba(0,0,0,0.1);
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }

  .panel {
    padding: 20px;
    border-bottom: 1px solid #e0e0e0;
  }

  .panel h3 {
    color: #0b3c5d;
    margin-bottom: 15px;
    font-size: 16px;
    border-bottom: 2px solid #0b3c5d;
    padding-bottom: 8px;
  }

  label {
    display: block;
    font-weight: 600;
    margin-top: 12px;
    margin-bottom: 6px;
    color: #333;
    font-size: 14px;
  }

  input {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 6px;
    font-size: 15px;
    transition: border 0.3s;
  }

  input:focus {
    border-color: #0b3c5d;
    outline: none;
  }

  .input-hint {
    font-size: 11px;
    color: #666;
    margin-top: 4px;
    font-style: italic;
  }

  .btn-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 15px;
  }

  button {
    padding: 12px;
    font-size: 14px;
    font-weight: bold;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s;
  }

  .btn-primary {
    background: linear-gradient(135deg, #0b3c5d 0%, #1a5276 100%);
    color: white;
    grid-column: span 2;
  }

  .btn-primary:hover {
    background: linear-gradient(135deg, #092f49 0%, #154360 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }

  .btn-danger {
    background: #e74c3c;
    color: white;
  }

  .btn-danger:hover {
    background: #c0392b;
    transform: translateY(-2px);
  }

  .btn-success {
    background: #2ecc71;
    color: white;
  }

  .btn-success:hover {
    background: #27ae60;
    transform: translateY(-2px);
  }

  #status {
    padding: 12px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 13px;
    margin-top: 15px;
    display: none;
    animation: slideIn 0.3s ease;
  }

  @keyframes slideIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .status-error {
    background: #ffebee;
    color: #c62828;
    border-left: 4px solid #c62828;
    display: block !important;
  }

  .status-success {
    background: #e8f5e9;
    color: #2e7d32;
    border-left: 4px solid #2e7d32;
    display: block !important;
  }

  .status-warning {
    background: #fff3e0;
    color: #ef6c00;
    border-left: 4px solid #ef6c00;
    display: block !important;
  }

  .info-box {
    background: #f8f9fa;
    border-radius: 6px;
    padding: 15px;
    border-left: 4px solid #2ecc71;
  }

  .info-box h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: #2e7d32;
    font-size: 15px;
  }

  .info-content {
    font-size: 13px;
    color: #555;
    line-height: 1.6;
  }

  .precision-badge {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: bold;
    margin-left: 6px;
  }

  .badge-exact { background: #4CAF50; color: white; }
  .badge-high { background: #2196F3; color: white; }
  .badge-approximate { background: #FF9800; color: white; }

  .points-list {
    max-height: 300px;
    overflow-y: auto;
    margin-top: 10px;
  }

  .point-item {
    padding: 12px;
    background: white;
    margin-bottom: 8px;
    border-radius: 6px;
    font-size: 12px;
    transition: all 0.2s;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .point-item:hover {
    transform: translateX(5px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }

  .point-exact { border-left: 4px solid #4CAF50; }
  .point-approximate { border-left: 4px solid #FF9800; }

  .quick-examples {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
  }

  .example-btn {
    padding: 8px 12px;
    font-size: 11px;
    background: #ff9800;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 600;
  }

  .example-btn:hover {
    background: #f57c00;
    transform: translateY(-2px);
  }

  .instructions {
    font-size: 12px;
    color: #555;
    background: #f8f9fa;
    padding: 12px;
    border-radius: 6px;
    line-height: 1.5;
  }

  .instructions strong {
    color: #0b3c5d;
    display: block;
    margin-bottom: 8px;
  }

  .instructions ul {
    margin: 0;
    padding-left: 18px;
  }

  .instructions li {
    margin-bottom: 6px;
  }

  ::-webkit-scrollbar {
    width: 8px;
  }

  ::-webkit-scrollbar-track {
    background: #f1f1f1;
  }

  ::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: #555;
  }

  @media (max-width: 1024px) {
    #container {
      flex-direction: column;
    }
    
    #mapArea {
      height: 60vh;
    }
    
    #sidebar {
      width: 100%;
      height: 40vh;
    }
  }
</style>
</head>

<body>

<header>
  <h1>üó∫Ô∏è Sistema de Valida√ß√£o - Sergipe (PDF Alta Qualidade)</h1>
  <p>Mapa Vetorial com Zoom Sem Perda | Arraste e Explore | 75 Munic√≠pios</p>
</header>

<div id="container">
  <div id="mapArea">
    <div id="loadingOverlay" class="loading-overlay">
      ‚è≥ Carregando mapa em alta resolu√ß√£o...
    </div>
    
    <div id="mapContainer">
      <canvas id="pdfCanvas"></canvas>
      <canvas id="markerCanvas"></canvas>
    </div>
    
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomIn()" title="Aumentar Zoom">+</button>
      <button class="zoom-btn" onclick="zoomOut()" title="Diminuir Zoom">‚àí</button>
      <button class="zoom-btn" onclick="resetZoom()" title="Resetar">‚åÇ</button>
    </div>
    
    <div class="info-overlay">
      <div id="zoomLevel">Zoom: 100%</div>
      <div id="qualityInfo" style="margin-top: 4px; font-size: 11px; opacity: 0.9;">
        Qualidade: PDF Vetorial
      </div>
    </div>
  </div>

  <div id="sidebar">
    <div class="panel">
      <h3>üéØ Pesquisa por Coordenadas</h3>
      
      <label>Latitude</label>
      <input id="lat" type="number" step="0.000001" placeholder="-10.947200">
      <div class="input-hint">Entre -11.550 e -9.600 (6 casas decimais)</div>
      
      <label>Longitude</label>
      <input id="lon" type="number" step="0.000001" placeholder="-37.073100">
      <div class="input-hint">Entre -38.300 e -36.380 (6 casas decimais)</div>

      <div class="btn-group">
        <button class="btn-primary" onclick="validateAndPlot()">‚úì Validar e Marcar</button>
        <button class="btn-danger" onclick="clearAllPoints()">üóëÔ∏è Limpar Pontos</button>
        <button class="btn-success" onclick="resetZoom()">üîÑ Reset Zoom</button>
      </div>

      <div id="status"></div>
    </div>

    <div class="panel">
      <h3>üìä Informa√ß√µes da Localiza√ß√£o</h3>
      <div class="info-box">
        <div id="locationInfo" class="info-content">
          Insira coordenadas para validar a localiza√ß√£o...
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>üìå Pontos Marcados (<span id="pointsCount">0</span>)</h3>
      <div class="points-list" id="pointsList">
        <div style="text-align: center; color: #999; padding: 20px; font-size: 13px;">
          Nenhum ponto marcado ainda
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>üöÄ Exemplos R√°pidos</h3>
      <div class="quick-examples" id="quickExamples"></div>
    </div>

    <div class="panel">
      <div class="instructions">
        <strong>üìñ Como usar o sistema:</strong>
        <ul>
          <li><strong>Zoom:</strong> Bot√µes + / ‚àí ou scroll do mouse</li>
          <li><strong>Mover:</strong> Arraste o mapa com o mouse</li>
          <li><strong>PDF Vetorial:</strong> Qualidade perfeita em qualquer zoom</li>
          <li><strong>Verde:</strong> Precis√£o &lt;5km do munic√≠pio</li>
          <li><strong>Laranja:</strong> Precis√£o &gt;5km do munic√≠pio</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<script>
// Configurar PDF.js
if (typeof pdfjsLib !== 'undefined') {
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
}

// ===================== CONFIGURA√á√ÉO DO MAPA PDF =====================
// Par√¢metros extra√≠dos do PDF do mapa de Sergipe
const MAP_CONFIG = {
  // Coordenadas geogr√°ficas do mapa (limites de Sergipe)
  latMin: -11.550,
  latMax: -9.600,
  lonMin: -38.300,
  lonMax: -36.380,
  
  // Coordenadas do mapa no PDF (em pontos - 1 ponto = 1/72 polegada)
  // Estas coordenadas representam os cantos do mapa no PDF
  mapPdfBounds: {
    top: 50,    // Dist√¢ncia do topo do PDF ao topo do mapa
    left: 50,   // Dist√¢ncia da esquerda do PDF √† esquerda do mapa
    width: 600, // Largura do mapa no PDF
    height: 550 // Altura do mapa no PDF
  },
  
  // URL dos arquivos
  pdfUrl: "./MAPA_ATUALIZADO_SERGIPE.pdf",
  
  // Configura√ß√µes de zoom
  zoom: 1,
  minZoom: 0.5,
  maxZoom: 8,
  zoomStep: 0.3,
  
  // Configura√ß√µes de renderiza√ß√£o
  pdfBaseScale: 2.0,  // Escala base para qualidade m√°xima
  
  // Transforma√ß√µes atuais
  offsetX: 0,
  offsetY: 0,
  
  // Estado de arraste
  isDragging: false,
  dragStartX: 0,
  dragStartY: 0,
  
  // Objetos PDF
  pdfDoc: null,
  pdfPage: null,
  viewport: null,
  
  // Pontos marcados
  markedPoints: [],
  
  // Cores
  colorExact: '#4CAF50',
  colorApproximate: '#FF9800',
  
  // Cache de dimens√µes
  cachedPdfWidth: 0,
  cachedPdfHeight: 0
};

// ===================== ELEMENTOS DO DOM =====================
const elements = {
  mapArea: document.getElementById('mapArea'),
  mapContainer: document.getElementById('mapContainer'),
  pdfCanvas: document.getElementById('pdfCanvas'),
  markerCanvas: document.getElementById('markerCanvas'),
  pdfCtx: null,
  markerCtx: null,
  loadingOverlay: document.getElementById('loadingOverlay'),
  zoomLevel: document.getElementById('zoomLevel'),
  qualityInfo: document.getElementById('qualityInfo'),
  status: document.getElementById('status'),
  locationInfo: document.getElementById('locationInfo'),
  pointsCount: document.getElementById('pointsCount'),
  pointsList: document.getElementById('pointsList')
};

// ===================== DADOS DOS MUNIC√çPIOS =====================
const municipios = [
  { nome: "Aracaju", lat: -10.9472, lon: -37.0731, regiao: "Regi√£o Metropolitana" },
  { nome: "Sim√£o Dias", lat: -10.7390, lon: -37.8100, regiao: "Centro-Sul" },
  { nome: "Itabaiana", lat: -10.6850, lon: -37.4250, regiao: "Agreste Central" },
  { nome: "Est√¢ncia", lat: -11.2619, lon: -37.4381, regiao: "Sul" },
  { nome: "Lagarto", lat: -10.9136, lon: -37.6689, regiao: "Centro-Sul" },
  { nome: "Propri√°", lat: -10.2108, lon: -36.8406, regiao: "Baixo S√£o Francisco" },
  { nome: "Po√ßo Redondo", lat: -9.8061, lon: -37.6839, regiao: "Alto Sert√£o" },
  { nome: "Tobias Barreto", lat: -11.1839, lon: -37.9989, regiao: "Centro-Sul" },
  { nome: "Nossa Senhora do Socorro", lat: -10.8550, lon: -37.1258, regiao: "Regi√£o Metropolitana" },
  { nome: "S√£o Crist√≥v√£o", lat: -11.0147, lon: -37.2064, regiao: "Regi√£o Metropolitana" },
  { nome: "Boquim", lat: -11.1489, lon: -37.6225, regiao: "Sul" },
  { nome: "Capela", lat: -10.5039, lon: -37.0528, regiao: "Agreste Central" },
  { nome: "Riach√£o do Dantas", lat: -11.0669, lon: -37.7283, regiao: "Centro-Sul" },
  { nome: "Cristin√°polis", lat: -11.4758, lon: -37.7550, regiao: "Sul" },
  { nome: "Umba√∫ba", lat: -11.3854, lon: -37.6597, regiao: "Sul" }
];

// ===================== CARREGAMENTO DO PDF =====================
async function loadPDF() {
  try {
    elements.loadingOverlay.style.display = 'block';
    elements.loadingOverlay.innerHTML = '‚è≥ Carregando mapa PDF...';
    
    console.log('üîÑ Carregando PDF:', MAP_CONFIG.pdfUrl);
    
    if (typeof pdfjsLib === 'undefined') {
      throw new Error('PDF.js n√£o est√° carregado');
    }
    
    const loadingTask = pdfjsLib.getDocument(MAP_CONFIG.pdfUrl);
    
    loadingTask.onProgress = function(progress) {
      const percent = Math.round((progress.loaded / progress.total) * 100);
      elements.loadingOverlay.innerHTML = `‚è≥ Carregando PDF: ${percent}%`;
    };
    
    MAP_CONFIG.pdfDoc = await loadingTask.promise;
    console.log('‚úÖ PDF carregado:', MAP_CONFIG.pdfDoc.numPages, 'p√°ginas');
    
    MAP_CONFIG.pdfPage = await MAP_CONFIG.pdfDoc.getPage(1);
    console.log('‚úÖ P√°gina 1 obtida');
    
    // Obter viewport base
    const baseViewport = MAP_CONFIG.pdfPage.getViewport({ scale: MAP_CONFIG.pdfBaseScale });
    MAP_CONFIG.viewport = baseViewport;
    
    // Calcular dimens√µes do mapa no PDF (assumindo que o mapa ocupa toda a p√°gina)
    // Se o mapa n√£o ocupa toda a p√°gina, ajuste estes valores
    MAP_CONFIG.cachedPdfWidth = baseViewport.width;
    MAP_CONFIG.cachedPdfHeight = baseViewport.height;
    
    console.log(`üìè Dimens√µes do PDF: ${baseViewport.width}x${baseViewport.height}px`);
    
    // Renderizar PDF inicial
    await renderPDF();
    
    elements.loadingOverlay.style.display = 'none';
    showStatus('‚úÖ Mapa PDF carregado em alta qualidade!', 'success');
    console.log('‚úÖ Sistema PDF inicializado');
    
  } catch (error) {
    console.error('‚ùå Erro ao carregar PDF:', error);
    elements.loadingOverlay.innerHTML = '‚ùå Erro ao carregar PDF. Verifique o arquivo.';
    elements.loadingOverlay.style.background = 'rgba(200, 0, 0, 0.8)';
  }
}

// ===================== RENDERIZA√á√ÉO DO PDF =====================
async function renderPDF() {
  try {
    if (!MAP_CONFIG.pdfPage) {
      throw new Error('P√°gina PDF n√£o carregada');
    }
    
    // Criar viewport com zoom aplicado
    const scale = MAP_CONFIG.pdfBaseScale * MAP_CONFIG.zoom;
    const viewport = MAP_CONFIG.pdfPage.getViewport({ scale: scale });
    
    console.log(`üìê Renderizando com escala ${scale.toFixed(2)} (zoom: ${MAP_CONFIG.zoom}x)`);
    
    // Configurar canvas do PDF
    elements.pdfCanvas.width = viewport.width;
    elements.pdfCanvas.height = viewport.height;
    
    elements.pdfCtx = elements.pdfCanvas.getContext('2d');
    
    // Limpar canvas
    elements.pdfCtx.clearRect(0, 0, elements.pdfCanvas.width, elements.pdfCanvas.height);
    
    // Renderizar PDF
    const renderContext = {
      canvasContext: elements.pdfCtx,
      viewport: viewport
    };
    
    await MAP_CONFIG.pdfPage.render(renderContext).promise;
    
    // Configurar canvas de marcadores (mesmo tamanho do PDF)
    elements.markerCanvas.width = viewport.width;
    elements.markerCanvas.height = viewport.height;
    
    if (!elements.markerCtx) {
      elements.markerCtx = elements.markerCanvas.getContext('2d');
    } else {
      // Apenas ajustar o tamanho, o contexto j√° existe
      elements.markerCtx.canvas.width = viewport.width;
      elements.markerCtx.canvas.height = viewport.height;
    }
    
    // Redesenhar todos os pontos marcados
    redrawAllPoints();
    
    console.log(`‚úÖ PDF renderizado: ${viewport.width}x${viewport.height}px`);
    
  } catch (error) {
    console.error('‚ùå Erro ao renderizar PDF:', error);
    showStatus('‚ùå Erro ao renderizar mapa', 'error');
  }
}

// ===================== CONVERS√ÉO DE COORDENADAS (CORRIGIDO) =====================
function latLonToPixels(lat, lon) {
  try {
    // Primeiro, normalizar coordenadas geogr√°ficas para 0-1
    const normX = (lon - MAP_CONFIG.lonMin) / (MAP_CONFIG.lonMax - MAP_CONFIG.lonMin);
    const normY = 1 - ((lat - MAP_CONFIG.latMin) / (MAP_CONFIG.latMax - MAP_CONFIG.latMin)); // Invertido porque Y=0 √© topo
    
    // Converter para pixels no PDF COM zoom aplicado
    // Usamos as dimens√µes do canvas atual (com zoom)
    const canvasWidth = elements.pdfCanvas.width;
    const canvasHeight = elements.pdfCanvas.height;
    
    // Calcular posi√ß√£o no canvas
    const x = normX * canvasWidth;
    const y = normY * canvasHeight;
    
    // Verificar se est√° dentro dos limites do canvas
    const valid = x >= 0 && x <= canvasWidth && y >= 0 && y <= canvasHeight;
    
    return { 
      x: Math.round(x), 
      y: Math.round(y), 
      valid: valid,
      normalized: { x: normX, y: normY }
    };
    
  } catch (error) {
    console.error('‚ùå Erro na convers√£o de coordenadas:', error);
    return { x: 0, y: 0, valid: false, normalized: { x: 0, y: 0 } };
  }
}

function pixelsToLatLon(x, y) {
  try {
    const canvasWidth = elements.pdfCanvas.width;
    const canvasHeight = elements.pdfCanvas.height;
    
    if (canvasWidth === 0 || canvasHeight === 0) {
      return { lat: 0, lon: 0, valid: false };
    }
    
    // Normalizar para 0-1
    const normX = x / canvasWidth;
    const normY = y / canvasHeight;
    
    // Converter para coordenadas geogr√°ficas (Y invertido)
    const lon = MAP_CONFIG.lonMin + (normX * (MAP_CONFIG.lonMax - MAP_CONFIG.lonMin));
    const lat = MAP_CONFIG.latMin + ((1 - normY) * (MAP_CONFIG.latMax - MAP_CONFIG.latMin));
    
    const valid = lat >= MAP_CONFIG.latMin && lat <= MAP_CONFIG.latMax &&
                  lon >= MAP_CONFIG.lonMin && lon <= MAP_CONFIG.lonMax;
    
    return { 
      lat: parseFloat(lat.toFixed(6)), 
      lon: parseFloat(lon.toFixed(6)), 
      valid: valid 
    };
    
  } catch (error) {
    console.error('‚ùå Erro na convers√£o inversa:', error);
    return { lat: 0, lon: 0, valid: false };
  }
}

// ===================== CONTROLES DE ZOOM E PAN =====================
function updateTransform() {
  const transform = `translate(${MAP_CONFIG.offsetX}px, ${MAP_CONFIG.offsetY}px)`;
  elements.mapContainer.style.transform = transform;
  elements.zoomLevel.textContent = `Zoom: ${Math.round(MAP_CONFIG.zoom * 100)}%`;
}

async function zoomIn() {
  if (MAP_CONFIG.zoom < MAP_CONFIG.maxZoom) {
    const oldZoom = MAP_CONFIG.zoom;
    MAP_CONFIG.zoom += MAP_CONFIG.zoomStep;
    MAP_CONFIG.zoom = Math.min(MAP_CONFIG.zoom, MAP_CONFIG.maxZoom);
    
    // Ajustar offset para manter o centro
    const zoomRatio = MAP_CONFIG.zoom / oldZoom;
    MAP_CONFIG.offsetX = MAP_CONFIG.offsetX * zoomRatio;
    MAP_CONFIG.offsetY = MAP_CONFIG.offsetY * zoomRatio;
    
    await renderPDF();
    updateTransform();
  }
}

async function zoomOut() {
  if (MAP_CONFIG.zoom > MAP_CONFIG.minZoom) {
    const oldZoom = MAP_CONFIG.zoom;
    MAP_CONFIG.zoom -= MAP_CONFIG.zoomStep;
    MAP_CONFIG.zoom = Math.max(MAP_CONFIG.zoom, MAP_CONFIG.minZoom);
    
    // Ajustar offset para manter o centro
    const zoomRatio = MAP_CONFIG.zoom / oldZoom;
    MAP_CONFIG.offsetX = MAP_CONFIG.offsetX * zoomRatio;
    MAP_CONFIG.offsetY = MAP_CONFIG.offsetY * zoomRatio;
    
    await renderPDF();
    updateTransform();
  }
}

async function resetZoom() {
  MAP_CONFIG.zoom = 1;
  MAP_CONFIG.offsetX = 0;
  MAP_CONFIG.offsetY = 0;
  
  await renderPDF();
  updateTransform();
  
  showStatus('üîÑ Zoom resetado para 100%', 'success');
}

// Zoom com scroll do mouse
elements.mapArea.addEventListener('wheel', async (e) => {
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? -MAP_CONFIG.zoomStep : MAP_CONFIG.zoomStep;
  const oldZoom = MAP_CONFIG.zoom;
  const newZoom = Math.max(MAP_CONFIG.minZoom, 
                          Math.min(MAP_CONFIG.maxZoom, MAP_CONFIG.zoom + delta));
  
  if (newZoom !== oldZoom) {
    // Calcular posi√ß√£o do mouse no canvas
    const rect = elements.mapArea.getBoundingClientRect();
    const mouseX = e.clientX - rect.left - MAP_CONFIG.offsetX;
    const mouseY = e.clientY - rect.top - MAP_CONFIG.offsetY;
    
    // Atualizar zoom
    MAP_CONFIG.zoom = newZoom;
    
    // Ajustar offset para zoom no ponto do mouse
    const zoomRatio = MAP_CONFIG.zoom / oldZoom;
    MAP_CONFIG.offsetX = MAP_CONFIG.offsetX * zoomRatio + (1 - zoomRatio) * mouseX;
    MAP_CONFIG.offsetY = MAP_CONFIG.offsetY * zoomRatio + (1 - zoomRatio) * mouseY;
    
    await renderPDF();
    updateTransform();
  }
});

// Arrastar mapa
elements.mapArea.addEventListener('mousedown', (e) => {
  MAP_CONFIG.isDragging = true;
  MAP_CONFIG.dragStartX = e.clientX - MAP_CONFIG.offsetX;
  MAP_CONFIG.dragStartY = e.clientY - MAP_CONFIG.offsetY;
  elements.mapArea.classList.add('dragging');
});

document.addEventListener('mousemove', (e) => {
  if (MAP_CONFIG.isDragging) {
    MAP_CONFIG.offsetX = e.clientX - MAP_CONFIG.dragStartX;
    MAP_CONFIG.offsetY = e.clientY - MAP_CONFIG.dragStartY;
    updateTransform();
  }
});

document.addEventListener('mouseup', () => {
  MAP_CONFIG.isDragging = false;
  elements.mapArea.classList.remove('dragging');
});

// ===================== VALIDA√á√ÉO DE COORDENADAS =====================
function validateCoordinates(lat, lon) {
  if (isNaN(lat) || isNaN(lon) || lat === '' || lon === '') {
    return "‚ùå Latitude e longitude s√£o obrigat√≥rias";
  }
  
  if (lat < -90 || lat > 90) {
    return "‚ùå Latitude inv√°lida (deve estar entre -90 e 90)";
  }
  
  if (lon < -180 || lon > 180) {
    return "‚ùå Longitude inv√°lida (deve estar entre -180 e 180)";
  }
  
  if (!isInsideSergipe(lat, lon)) {
    return `‚ùå Coordenada fora dos limites de Sergipe<br>
            <small>Latitude: ${MAP_CONFIG.latMin}¬∞ a ${MAP_CONFIG.latMax}¬∞<br>
            Longitude: ${MAP_CONFIG.lonMin}¬∞ a ${MAP_CONFIG.lonMax}¬∞</small>`;
  }
  
  return null;
}

function isInsideSergipe(lat, lon) {
  return lat >= MAP_CONFIG.latMin && lat <= MAP_CONFIG.latMax &&
         lon >= MAP_CONFIG.lonMin && lon <= MAP_CONFIG.lonMax;
}

// ===================== DETEC√á√ÉO DE MUNIC√çPIO =====================
function getMunicipioInfo(lat, lon) {
  let municipioMaisProximo = null;
  let menorDistancia = Infinity;
  
  municipios.forEach(municipio => {
    // F√≥rmula de Haversine simplificada (aproxima√ß√£o para dist√¢ncias curtas)
    const dLat = (lat - municipio.lat) * 111.32; // 1 grau ‚âà 111.32 km
    const dLon = (lon - municipio.lon) * 111.32 * Math.cos(lat * Math.PI / 180);
    const distancia = Math.sqrt(dLat * dLat + dLon * dLon);
    
    if (distancia < menorDistancia) {
      menorDistancia = distancia;
      municipioMaisProximo = municipio;
    }
  });
  
  let precisao, tipoPrecisao;
  
  if (menorDistancia < 5) {
    precisao = "EXATA";
    tipoPrecisao = "exact";
  } else if (menorDistancia < 15) {
    precisao = "ALTA";
    tipoPrecisao = "high";
  } else {
    precisao = "APROXIMADA";
    tipoPrecisao = "approximate";
  }
  
  return {
    nome: municipioMaisProximo.nome,
    regiao: municipioMaisProximo.regiao,
    distancia: menorDistancia,
    precisao: precisao,
    tipoPrecisao: tipoPrecisao
  };
}

function updateLocationInfo(lat, lon) {
  const info = getMunicipioInfo(lat, lon);
  
  const badgeClass = info.tipoPrecisao === 'exact' ? 'badge-exact' : 
                     info.tipoPrecisao === 'high' ? 'badge-high' : 'badge-approximate';
  
  elements.locationInfo.innerHTML = `
    <div style="margin-bottom: 10px;">
      <strong>üìç Munic√≠pio:</strong><br>
      <span style="font-size: 16px; color: #0b3c5d; font-weight: bold;">${info.nome}</span>
      <span class="precision-badge ${badgeClass}">${info.precisao}</span>
    </div>
    <div style="margin-bottom: 8px;">
      <strong>üó∫Ô∏è Regi√£o:</strong> ${info.regiao}
    </div>
    <div style="margin-bottom: 8px;">
      <strong>üìè Dist√¢ncia:</strong> ${info.distancia.toFixed(2)} km do centro
    </div>
    <div style="margin-bottom: 8px;">
      <strong>üéØ Coordenadas:</strong><br>
      Lat: ${lat.toFixed(6)}¬∞ | Lon: ${lon.toFixed(6)}¬∞
    </div>
    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 11px; color: #666;">
      <strong>üí° Nota:</strong> Dist√¢ncia calculada do centro do munic√≠pio mais pr√≥ximo
    </div>
  `;
}

// ===================== DESENHO DE PONTOS =====================
function drawPoint(x, y, label, precisao) {
  if (!elements.markerCtx) return;
  
  const color = precisao === 'exact' || precisao === 'high' ? 
                MAP_CONFIG.colorExact : MAP_CONFIG.colorApproximate;
  
  const ctx = elements.markerCtx;
  const radius = 8 * MAP_CONFIG.zoom; // Tamanho ajustado pelo zoom
  
  // C√≠rculo externo (sombra)
  ctx.beginPath();
  ctx.arc(x, y, radius * 2.2, 0, Math.PI * 2);
  ctx.fillStyle = color + '20';
  ctx.fill();
  
  // C√≠rculo intermedi√°rio
  ctx.beginPath();
  ctx.arc(x, y, radius * 1.5, 0, Math.PI * 2);
  ctx.fillStyle = color + '60';
  ctx.fill();
  
  // C√≠rculo principal
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
  
  // Borda branca
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = Math.max(2, 2 * MAP_CONFIG.zoom);
  ctx.stroke();
  
  // Cruz central
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = Math.max(1, 1.5 * MAP_CONFIG.zoom);
  ctx.beginPath();
  ctx.moveTo(x - radius * 0.6, y);
  ctx.lineTo(x + radius * 0.6, y);
  ctx.moveTo(x, y - radius * 0.6);
  ctx.lineTo(x, y + radius * 0.6);
  ctx.stroke();
  
  // Label (somente se zoom suficiente)
  if (label && MAP_CONFIG.zoom > 0.8) {
    ctx.font = `bold ${Math.max(12, 14 * MAP_CONFIG.zoom)}px Arial`;
    const textWidth = ctx.measureText(label).width;
    
    // Fundo do texto
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(x - textWidth/2 - 6, y - radius - 25, textWidth + 12, 20);
    
    // Texto
    ctx.fillStyle = '#FFFFFF';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x, y - radius - 15);
  }
}

function redrawAllPoints() {
  if (!elements.markerCtx) return;
  
  // Limpar canvas de marcadores
  elements.markerCtx.clearRect(0, 0, elements.markerCanvas.width, elements.markerCanvas.height);
  
  // Redesenhar todos os pontos
  MAP_CONFIG.markedPoints.forEach(point => {
    if (point.valid) {
      const coords = latLonToPixels(point.lat, point.lon);
      if (coords.valid) {
        drawPoint(coords.x, coords.y, point.label, point.tipoPrecisao);
      }
    }
  });
  
  updatePointsList();
}

function addPoint(lat, lon) {
  const coords = latLonToPixels(lat, lon);
  
  if (!coords.valid) {
    showStatus('‚ùå Erro: Coordenada fora do mapa vis√≠vel', 'error');
    return false;
  }
  
  const info = getMunicipioInfo(lat, lon);
  const label = `P${MAP_CONFIG.markedPoints.length + 1}`;
  
  MAP_CONFIG.markedPoints.push({
    lat: lat,
    lon: lon,
    label: label,
    timestamp: new Date().toLocaleTimeString('pt-BR'),
    municipio: info.nome,
    regiao: info.regiao,
    precisao: info.precisao,
    tipoPrecisao: info.tipoPrecisao,
    distancia: info.distancia,
    valid: true
  });
  
  updateLocationInfo(lat, lon);
  redrawAllPoints();
  return true;
}

function clearAllPoints() {
  MAP_CONFIG.markedPoints = [];
  redrawAllPoints();
  showStatus('üóëÔ∏è Todos os pontos foram removidos', 'success');
  elements.locationInfo.innerHTML = 'Insira coordenadas para validar a localiza√ß√£o...';
}

function updatePointsList() {
  elements.pointsCount.textContent = MAP_CONFIG.markedPoints.length;
  
  if (MAP_CONFIG.markedPoints.length === 0) {
    elements.pointsList.innerHTML = `
      <div style="text-align: center; color: #999; padding: 20px; font-size: 13px;">
        Nenhum ponto marcado ainda
      </div>
    `;
    return;
  }
  
  let html = '';
  MAP_CONFIG.markedPoints.forEach((point, index) => {
    const itemClass = point.tipoPrecisao === 'exact' || point.tipoPrecisao === 'high' ? 
                      'point-exact' : 'point-approximate';
    const badgeClass = point.tipoPrecisao === 'exact' ? 'badge-exact' : 
                       point.tipoPrecisao === 'high' ? 'badge-high' : 'badge-approximate';
    
    html += `
      <div class="point-item ${itemClass}">
        <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
          <strong style="color: #0b3c5d;">${point.label}</strong>
          <span class="precision-badge ${badgeClass}">${point.precisao}</span>
        </div>
        <div style="line-height: 1.5;">
          üìç <strong>${point.municipio}</strong> (${point.regiao})<br>
          üéØ ${point.lat.toFixed(6)}¬∞, ${point.lon.toFixed(6)}¬∞<br>
          üìè ${point.distancia.toFixed(2)} km | ‚è∞ ${point.timestamp}
        </div>
        <div style="margin-top: 8px; display: flex; gap: 5px;">
          <button onclick="centerOnPoint(${index})" style="font-size: 10px; padding: 3px 8px; background: #0b3c5d; color: white; border: none; border-radius: 3px; cursor: pointer;">
            Centralizar
          </button>
          <button onclick="removePoint(${index})" style="font-size: 10px; padding: 3px 8px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">
            Remover
          </button>
        </div>
      </div>
    `;
  });
  
  elements.pointsList.innerHTML = html;
}

function centerOnPoint(index) {
  if (index >= 0 && index < MAP_CONFIG.markedPoints.length) {
    const point = MAP_CONFIG.markedPoints[index];
    centerOnCoordinates(point.lat, point.lon);
    
    // Atualizar campos de entrada
    document.getElementById('lat').value = point.lat;
    document.getElementById('lon').value = point.lon;
    
    updateLocationInfo(point.lat, point.lon);
    showStatus(`üìç Centralizado em ${point.municipio}`, 'success');
  }
}

function removePoint(index) {
  if (index >= 0 && index < MAP_CONFIG.markedPoints.length) {
    const removed = MAP_CONFIG.markedPoints.splice(index, 1)[0];
    redrawAllPoints();
    showStatus(`üóëÔ∏è Ponto ${removed.label} removido`, 'success');
  }
}

function centerOnCoordinates(lat, lon) {
  const coords = latLonToPixels(lat, lon);
  if (!coords.valid) return;
  
  const mapArea = elements.mapArea.getBoundingClientRect();
  
  // Centralizar no ponto
  MAP_CONFIG.offsetX = mapArea.width / 2 - coords.x;
  MAP_CONFIG.offsetY = mapArea.height / 2 - coords.y;
  
  updateTransform();
}

// ===================== FUN√á√ïES PRINCIPAIS =====================
function validateAndPlot() {
  const latInput = document.getElementById('lat').value;
  const lonInput = document.getElementById('lon').value;
  
  if (!latInput || !lonInput) {
    showStatus('‚ùå Por favor, preencha latitude e longitude', 'error');
    return;
  }
  
  const lat = parseFloat(latInput);
  const lon = parseFloat(lonInput);
  
  const error = validateCoordinates(lat, lon);
  if (error) {
    showStatus(error, 'error');
    return;
  }
  
  const success = addPoint(lat, lon);
  
  if (success) {
    const info = getMunicipioInfo(lat, lon);
    showStatus(
      `‚úÖ Ponto marcado com sucesso!<br>
       üìç <strong>${info.nome}</strong> (${info.regiao})<br>
       üéØ Precis√£o: ${info.precisao} - ${info.distancia.toFixed(2)} km`,
      'success'
    );
    
    centerOnCoordinates(lat, lon);
  }
}

function showStatus(message, type) {
  elements.status.innerHTML = message;
  elements.status.className = `status-${type}`;
  elements.status.style.display = 'block';
  
  // Auto-ocultar mensagens de sucesso ap√≥s 5 segundos
  if (type === 'success') {
    setTimeout(() => {
      elements.status.style.display = 'none';
    }, 5000);
  }
}

// ===================== CLIQUE NO MAPA PARA ADICIONAR PONTO =====================
elements.markerCanvas.addEventListener('click', (e) => {
  if (!MAP_CONFIG.isDragging) { // S√≥ adicionar ponto se n√£o estiver arrastando
    const rect = elements.markerCanvas.getBoundingClientRect();
    const scaleX = elements.markerCanvas.width / rect.width;
    const scaleY = elements.markerCanvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    const coords = pixelsToLatLon(x, y);
    
    if (coords.valid) {
      // Preencher campos
      document.getElementById('lat').value = coords.lat.toFixed(6);
      document.getElementById('lon').value = coords.lon.toFixed(6);
      
      // Adicionar ponto
      const success = addPoint(coords.lat, coords.lon);
      
      if (success) {
        const info = getMunicipioInfo(coords.lat, coords.lon);
        showStatus(`üìç Ponto adicionado via clique: ${info.nome}`, 'success');
      }
    }
  }
});

// ===================== INICIALIZA√á√ÉO =====================
document.addEventListener('DOMContentLoaded', async () => {
  // Carregar PDF
  await loadPDF();
  
  // Evento Enter para validar
  document.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      const activeElement = document.activeElement;
      if (activeElement.id === 'lat' || activeElement.id === 'lon') {
        validateAndPlot();
      }
    }
  });
  
  // Criar bot√µes de exemplo
  const exemplos = [
    { lat: -10.947200, lon: -37.073100, name: 'Aracaju' },
    { lat: -10.739000, lon: -37.810000, name: 'Sim√£o Dias' },
    { lat: -10.685000, lon: -37.425000, name: 'Itabaiana' },
    { lat: -11.261900, lon: -37.438100, name: 'Est√¢ncia' },
    { lat: -10.210800, lon: -36.840600, name: 'Propri√°' },
    { lat: -9.806100, lon: -37.683900, name: 'Po√ßo Redondo' },
    { lat: -11.475800, lon: -37.755000, name: 'Cristin√°polis' },
    { lat: -10.503900, lon: -37.052800, name: 'Capela' }
  ];
  
  const exampleDiv = document.getElementById('quickExamples');
  exemplos.forEach(ex => {
    const btn = document.createElement('button');
    btn.className = 'example-btn';
    btn.textContent = ex.name;
    btn.onclick = () => {
      document.getElementById('lat').value = ex.lat;
      document.getElementById('lon').value = ex.lon;
      validateAndPlot();
    };
    exampleDiv.appendChild(btn);
  });
  
  // Exibir informa√ß√µes do sistema
  console.log('üó∫Ô∏è Sistema PDF de Sergipe inicializado');
  console.log(`üìè Limites geogr√°ficos: Lat[${MAP_CONFIG.latMin}, ${MAP_CONFIG.latMax}] Lon[${MAP_CONFIG.lonMin}, ${MAP_CONFIG.lonMax}]`);
  console.log(`üîß Configura√ß√µes: Escala base=${MAP_CONFIG.pdfBaseScale} | Zoom m√°ximo=${MAP_CONFIG.maxZoom}x`);
  console.log(`üìç ${municipios.length} munic√≠pios carregados`);
});

// Fun√ß√µes globais para acesso via HTML
window.validateAndPlot = validateAndPlot;
window.clearAllPoints = clearAllPoints;
window.resetZoom = resetZoom;
window.zoomIn = zoomIn;
window.zoomOut = zoomOut;
window.centerOnPoint = centerOnPoint;
window.removePoint = removePoint;
</script>
</body>
</html>
