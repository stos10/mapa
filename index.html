<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Sistema de Rota com Delimita√ß√£o Territorial</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- LEAFLET -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- ROUTING -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css"/>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

<!-- MARKER CLUSTER -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<!-- SHEETJS PARA EXCEL -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

<style>
html, body {
  height: 100%;
  margin: 0;
  font-family: system-ui, sans-serif;
}

#map { height: 100%; }

/* HEADER */
.header {
  position: fixed;
  top: 0;
  width: 100%;
  background: linear-gradient(135deg,#0b3c5d,#1a5276);
  color: white;
  padding: 10px;
  z-index: 1000;
}

.header h1 {
  font-size: 15px;
  margin: 0;
}

/* SEARCH */
.search-bar {
  position: fixed;
  top: 55px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 6px;
  background: rgba(255,255,255,.97);
  padding: 6px;
  border-radius: 10px;
  z-index: 1000;
}

.search-bar input {
  width: 110px;
  padding: 6px;
  font-size: 13px;
}

.search-bar button {
  padding: 6px 10px;
  background: #0b3c5d;
  color: white;
  border: none;
  border-radius: 6px;
}

/* CONTROLS */
.controls {
  position: fixed;
  right: 10px;
  bottom: 20px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 1000;
}

.controls button {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: none;
  font-size: 18px;
  box-shadow: 0 3px 10px rgba(0,0,0,.3);
}

/* INFO */
.info {
  position: fixed;
  left: 10px;
  bottom: 20px;
  background: rgba(255,255,255,.95);
  padding: 10px;
  border-radius: 8px;
  font-size: 12px;
  z-index: 1000;
}

.toast {
  position: fixed;
  top: 115px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(40,40,40,.95);
  color: white;
  padding: 10px 16px;
  border-radius: 8px;
  display: none;
  z-index: 2000;
}

/* MODAL LOTE */
.modal-lote {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 3000;
}

.modal-lote-content {
  background: white;
  padding: 15px;
  border-radius: 8px;
  width: 90%;
  max-width: 400px;
  max-height: 80%;
  overflow-y: auto;
}

.modal-lote h3 {
  margin: 0 0 10px 0;
  color: #2c3e50;
  font-size: 16px;
}

.modal-lote p {
  margin: 5px 0;
  font-size: 13px;
  color: #34495e;
}

.modal-lote-buttons {
  display: flex;
  gap: 8px;
  margin-top: 15px;
  justify-content: flex-end;
}

.modal-lote-buttons button {
  padding: 6px 12px;
  border: none;
  border-radius: 5px;
  font-size: 13px;
  cursor: pointer;
}
</style>
</head>

<body>

<div class="header">
  <h1>üó∫Ô∏è Rota com Delimita√ß√£o Territorial (Escala M√°xima)</h1>
</div>

<div class="search-bar">
  <input id="latInput" placeholder="Latitude">
  <input id="lngInput" placeholder="Longitude">
  <button onclick="searchDestination()">üîç</button>
</div>

<div id="map"></div>

<div class="controls">
  <button onclick="abrirModalLote()" title="Rotas em Lote">üìä</button>
  <button onclick="resetView()">üéØ</button>
  <button onclick="toggleLayer()">üõ∞Ô∏è</button>
  <button onclick="clearAll()">üóëÔ∏è</button>
</div>

<div class="info">
  <div><strong>Status:</strong> <span id="status">Aguardando</span></div>
</div>

<div class="toast" id="toast"></div>

<!-- MODAL PARA ROTAS EM LOTE -->
<div class="modal-lote" id="modalLote">
  <div class="modal-lote-content">
    <h3>üìã Rotas em Lote (Excel)</h3>
    <p>Importe um arquivo Excel com coordenadas.</p>
    <p><strong>Formato:</strong> Coluna A = Latitude, Coluna B = Longitude</p>
    
    <input type="file" id="excelFile" accept=".xlsx,.xls" style="margin: 10px 0; width: 100%; font-size: 13px;">
    
    <div style="margin: 10px 0; font-size: 12px; color: #7f8c8d;">
      <strong>Exemplo do arquivo anexo:</strong>
      <div style="background: #f8f9fa; padding: 5px; border-radius: 3px; margin-top: 3px; font-family: monospace;">
        -10.91379 | -37.05855<br>
        -10.91306 | -37.06087<br>
        -10.89505 | -37.05463
      </div>
      <p style="margin-top: 5px;"><small>*Use coordenadas no formato decimal (ex: -10.91379)</small></p>
    </div>
    
    <div class="modal-lote-buttons">
      <button onclick="fecharModalLote()" style="background: #95a5a6; color: white;">Cancelar</button>
      <button onclick="processarLote()" style="background: #0b3c5d; color: white;">Processar</button>
    </div>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
const CONFIG = {
  center: [-10.5746, -37.3857],
  zoom: 8,
  bounds: [[-11.55,-38.30],[-9.60,-36.38]]
};

const ARRIVAL_RADIUS = 30;
const STORAGE_KEY = "territory_points";

/* ================= VARI√ÅVEIS ================= */
let map, street, satellite;
let baseLayer = "street";

let destination = null;
let destinationMarker = null;
let routingControl = null;
let watchId = null;

/* TERRIT√ìRIO ESCAL√ÅVEL */
let territoryMarkers = L.markerClusterGroup({
  disableClusteringAtZoom: 17,
  maxClusterRadius: 60
});
let territoryPolygon = null;

/* VARI√ÅVEIS PARA LOTE */
let rotasEmLote = [];
let currentBatchMarker = null; // Para evitar duplica√ß√£o do marcador atual

/* ================= INIT ================= */
map = L.map("map", { maxBounds: CONFIG.bounds })
  .setView(CONFIG.center, CONFIG.zoom);

street = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png");
satellite = L.tileLayer(
 "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
);

street.addTo(map);

/* ================= STORAGE ================= */
function getStoredTerritory() {
  return JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
}

function saveTerritory(points) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(points));
}

/* ================= TERRITORY DRAW ================= */
function drawTerritory() {
  const points = getStoredTerritory();

  territoryMarkers.clearLayers();
  if (territoryPolygon) map.removeLayer(territoryPolygon);

  if (points.length === 0) return;

  points.forEach((p, i) => {
    const marker = L.circleMarker(p, {
      radius: 6,
      color: "#0b3c5d",
      fillColor: "#3498db",
      fillOpacity: 0.9
    }).bindPopup(`üìç Ponto territorial #${i + 1}`);

    territoryMarkers.addLayer(marker);
  });

  if (points.length >= 3) {
    territoryPolygon = L.polygon(points, {
      color: "#2980b9",
      fillColor: "#85c1e9",
      fillOpacity: 0.25
    }).addTo(map);
  }

  map.addLayer(territoryMarkers);
  document.getElementById("status").innerText =
    `Territ√≥rio ativo (${points.length} pontos)`;
}

function addTerritoryPoint(lat, lng) {
  const points = getStoredTerritory();
  points.push([lat, lng]);
  saveTerritory(points);
  drawTerritory();
}

drawTerritory();

/* ================= MAP ================= */
function toggleLayer() {
  if (baseLayer === "street") {
    map.removeLayer(street);
    satellite.addTo(map);
    baseLayer = "satellite";
  } else {
    map.removeLayer(satellite);
    street.addTo(map);
    baseLayer = "street";
  }
}

function searchDestination() {
  const lat = parseFloat(latInput.value);
  const lng = parseFloat(lngInput.value);

  if (isNaN(lat) || isNaN(lng)) {
    toast("‚ùå Coordenadas inv√°lidas");
    return;
  }

  destination = L.latLng(lat, lng);
  addTerritoryPoint(lat, lng);

  if (destinationMarker) map.removeLayer(destinationMarker);

  destinationMarker = L.circleMarker(destination, {
    radius: 9,
    color: "#fff",
    fillColor: "#e74c3c",
    fillOpacity: .95
  }).addTo(map).bindPopup("üìç Destino").openPopup();

  map.setView(destination, 15);
  startRoute();
}

function startRoute() {
  navigator.geolocation.getCurrentPosition(pos => {
    const userPos = L.latLng(pos.coords.latitude, pos.coords.longitude);

    if (routingControl) map.removeControl(routingControl);

    routingControl = L.Routing.control({
      waypoints: [userPos, destination],
      addWaypoints: false,
      draggableWaypoints: false,
      show: false,
      createMarker: () => null,
      lineOptions: { styles: [{ weight: 5 }] }
    }).addTo(map);

    monitorArrival();
  }, () => toast("‚ùå Erro ao obter GPS"), { enableHighAccuracy:true });
}

function monitorArrival() {
  if (watchId) navigator.geolocation.clearWatch(watchId);

  watchId = navigator.geolocation.watchPosition(pos => {
    const userPos = L.latLng(pos.coords.latitude, pos.coords.longitude);
    if (userPos.distanceTo(destination) <= ARRIVAL_RADIUS) {
      navigator.geolocation.clearWatch(watchId);
      toast("üè† Chegada confirmada");
    }
  }, null, { enableHighAccuracy:true });
}

function resetView() {
  map.setView(CONFIG.center, CONFIG.zoom);
}

function clearAll() {
  // Limpar rota individual
  if (destinationMarker) map.removeLayer(destinationMarker);
  if (routingControl) map.removeControl(routingControl);
  if (watchId) navigator.geolocation.clearWatch(watchId);
  
  // Limpar lote
  limparRotasLote();
  
  // Limpar territ√≥rio
  territoryMarkers.clearLayers();
  if (territoryPolygon) map.removeLayer(territoryPolygon);
  localStorage.removeItem(STORAGE_KEY);
  
  // Resetar vari√°veis
  destination = null;
  destinationMarker = null;
  routingControl = null;
  territoryPolygon = null;
  
  document.getElementById("status").innerText = "Aguardando";
  toast("üóëÔ∏è Territ√≥rio apagado");
}

function limparRotasLote() {
  rotasEmLote.forEach(rota => {
    if (rota.control) {
      try {
        map.removeControl(rota.control);
      } catch(e) {
        // Ignorar erros de remo√ß√£o
      }
    }
    if (rota.marker && map.hasLayer(rota.marker)) {
      map.removeLayer(rota.marker);
    }
  });
  rotasEmLote = [];
}

function toast(msg) {
  const t = document.getElementById("toast");
  t.innerText = msg;
  t.style.display = "block";
  setTimeout(() => t.style.display = "none", 2500);
}

/* ================= FUN√á√ïES DE LOTE ================= */
function abrirModalLote() {
  document.getElementById('modalLote').style.display = 'flex';
  document.getElementById('excelFile').value = '';
}

function fecharModalLote() {
  document.getElementById('modalLote').style.display = 'none';
}

async function processarLote() {
  const fileInput = document.getElementById('excelFile');
  const file = fileInput.files[0];
  
  if (!file) {
    toast("‚ùå Selecione um arquivo Excel");
    return;
  }
  
  try {
    // Ler arquivo Excel
    const coordenadas = await readExcelFile(file);
    
    if (coordenadas.length === 0) {
      toast("‚ùå Nenhuma coordenada encontrada");
      return;
    }
    
    toast(`üìä Processando ${coordenadas.length} destino(s)...`);
    
    // Obter posi√ß√£o atual UMA VEZ para todas as rotas
    const posicaoAtual = await obterPosicaoAtual();
    const userPos = L.latLng(posicaoAtual.coords.latitude, posicaoAtual.coords.longitude);
    
    // Limpar rotas anteriores do lote
    limparRotasLote();
    
    // Processar CADA destino EXATAMENTE como na busca individual
    for (let i = 0; i < coordenadas.length; i++) {
      const coord = coordenadas[i];
      const destLatLng = L.latLng(coord.lat, coord.lng);
      
      // 1. ADICIONAR AO TERRIT√ìRIO (igual √† busca individual)
      addTerritoryPoint(coord.lat, coord.lng);
      
      // 2. CRIAR MARCADOR VERMELHO (EXATAMENTE IGUAL √† busca individual)
      const marker = L.circleMarker(destLatLng, {
        radius: 9,  // MESMO tamanho
        color: "#fff",  // MESMA cor branca
        fillColor: "#e74c3c",  // MESMA cor vermelha
        fillOpacity: .95  // MESMA opacidade
      }).addTo(map).bindPopup(`üìç Destino ${i+1}<br>Lat: ${coord.lat.toFixed(6)}<br>Lng: ${coord.lng.toFixed(6)}`);
      
      // 3. CRIAR ROTA (igual √† busca individual, mas SEM interface)
      const routeControl = L.Routing.control({
        waypoints: [userPos, destLatLng],
        addWaypoints: false,
        draggableWaypoints: false,
        show: false,  // N√ÉO mostrar painel de rota
        createMarker: () => null,  // N√ÉO criar marcadores extras
        lineOptions: { 
          styles: [{ 
            weight: 5,  // MESMA espessura
            color: '#e74c3c',  // MESMA cor vermelha da rota individual
            opacity: 0.7 
          }] 
        },
        // IMPORTANTE: Evitar que a rota interfira com o mapa
        routeWhileDragging: false,
        fitSelectedRoutes: false,
        showAlternatives: false
      });
      
      // Adicionar ao mapa MAS sem o painel de controle vis√≠vel
      routeControl.addTo(map);
      
      // Esconder imediatamente qualquer painel que apare√ßa
      setTimeout(() => {
        const container = routeControl.getContainer();
        if (container) {
          container.style.display = 'none';
        }
      }, 100);
      
      // Guardar refer√™ncia para poder remover depois
      rotasEmLote.push({
        control: routeControl,
        marker: marker,
        lat: coord.lat,
        lng: coord.lng
      });
      
      // Pequena pausa para n√£o sobrecarregar
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    fecharModalLote();
    toast(`‚úÖ ${coordenadas.length} rota(s) criada(s) com sucesso!`);
    
    // Atualizar status
    const totalPontos = getStoredTerritory().length;
    document.getElementById("status").innerText = 
      `Lote: ${coordenadas.length} destino(s) | Total: ${totalPontos} pontos`;
    
    // Centralizar no primeiro destino
    if (coordenadas.length > 0) {
      map.setView([coordenadas[0].lat, coordenadas[0].lng], 12);
    }
    
  } catch (error) {
    console.error("Erro:", error);
    toast("‚ùå Erro ao processar arquivo: " + error.message);
  }
}

function readExcelFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = function(e) {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        
        // Primeira planilha
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        
        // Converter para JSON (array de arrays)
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        
        const coordenadas = [];
        
        // CORRE√á√ÉO: Converter coordenadas do exemplo
        // Se vier n√∫meros grandes como -1091379, dividir por 100000
        for (let i = 0; i < jsonData.length; i++) {
          const linha = jsonData[i];
          
          if (linha && linha.length >= 2) {
            let lat = parseFloat(linha[0]);
            let lng = parseFloat(linha[1]);
            
            // CORRE√á√ÉO PARA O FORMATO DO SEU ARQUIVO
            // Se os n√∫meros forem muito grandes (ex: -1091379), dividir
            if (Math.abs(lat) > 1000) {
              lat = lat / 100000;
            }
            if (Math.abs(lng) > 1000) {
              lng = lng / 100000;
            }
            
            if (!isNaN(lat) && !isNaN(lng)) {
              coordenadas.push({ 
                lat: lat, 
                lng: lng,
                original: { lat: linha[0], lng: linha[1] }
              });
            }
          }
        }
        
        resolve(coordenadas);
      } catch (error) {
        reject(error);
      }
    };
    
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

function obterPosicaoAtual() {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(resolve, reject, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    });
  });
}

/* ================= EVENT LISTENERS ================= */
// Fechar modal com ESC
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    fecharModalLote();
  }
});

// Fechar modal ao clicar fora
document.getElementById('modalLote').addEventListener('click', function(e) {
  if (e.target === this) {
    fecharModalLote();
  }
});

// Adicionar ponto ao clicar no mapa (FUNCIONALIDADE ORIGINAL)
map.on('click', function(e) {
  const lat = e.latlng.lat;
  const lng = e.latlng.lng;
  
  document.getElementById('latInput').value = lat.toFixed(6);
  document.getElementById('lngInput').value = lng.toFixed(6);
});
</script>

</body>
</html>
